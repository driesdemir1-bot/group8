SET datestyle = 'ISO, DMY';  -- ensure DD/MM/YYYY casts behave as expected

-- Create entity MOVIES - All
CREATE TABLE IF NOT EXISTS public.movie (
  movie_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,  -- surrogate key for stable references
  url      TEXT NOT NULL,
  title    TEXT NOT NULL,
  reldate  DATE NOT NULL,
  CONSTRAINT movie_url_uk                UNIQUE (url),            -- keep url unique for idempotent loads
  CONSTRAINT movie_title_reldate_uk      UNIQUE (title, reldate)  -- natural key kept for data quality
);

-- Load movies uit raw.metaclean_raw
INSERT INTO public.movie (url, title, reldate)
SELECT DISTINCT                          -- guard against duplicate source rows
  m."url",
  m."title",
  NULLIF(m."reldate", '')::DATE          -- empty string -> NULL before DATE cast to avoid 22P02
FROM raw.metaclean_raw m
WHERE NULLIF(m."url",'') IS NOT NULL     -- drop incomplete rows (avoid nulls into NOT NULL columns)
  AND NULLIF(m."title",'') IS NOT NULL
  AND NULLIF(m."reldate",'') IS NOT NULL
ON CONFLICT (url) DO UPDATE              -- upsert by url so re-runs are safe
SET title = EXCLUDED.title,
    reldate = EXCLUDED.reldate;

-- Create entity PERFORMANCE - Idris
CREATE TABLE IF NOT EXISTS public.performance (
  movie_id                  BIGINT PRIMARY KEY
    REFERENCES public.movie(movie_id) ON UPDATE CASCADE ON DELETE RESTRICT,  -- 1:1 with movie via surrogate key
  production_budget         NUMERIC(14,2),
  worldwide_box_office      NUMERIC(14,2),
  opening_weekend_revenue   NUMERIC(14,2)
);

-- Load performance via title+date -> movie_id
INSERT INTO public.performance (movie_id, production_budget, worldwide_box_office, opening_weekend_revenue)
SELECT DISTINCT ON (m.movie_id)          -- choose a single sales row per movie
  m.movie_id,
  NULLIF(regexp_replace(s."production_budget",    '[^0-9\.-]', '', 'g'), '')::NUMERIC(14,2),    -- strip currency/commas etc, empty->NULL, then cast
  NULLIF(regexp_replace(s."worldwide_box_office", '[^0-9\.-]', '', 'g'), '')::NUMERIC(14,2),    -- same normalization pattern
  NULLIF(regexp_replace(s."opening_weekend",      '[^0-9\.-]', '', 'g'), '')::NUMERIC(14,2)     -- keep two decimals consistently
FROM raw.sales_raw s
JOIN public.movie m
  ON m.title = s."title"                                                           -- resolve movie_id via natural key
 AND m.reldate = to_date(s."date_normalized",'DD/MM/YYYY')                         -- explicit format to avoid locale surprises
WHERE s."date_normalized" ~ '^\d{2}/\d{2}/\d{4}$'                                  -- guard: only rows with expected date format
ORDER BY m.movie_id;                                                                -- pairs with DISTINCT ON for deterministic pick


-- Create entity DISTRIBUTION - Tristan 
CREATE TABLE IF NOT EXISTS public.distribution (
  movie_id                  BIGINT PRIMARY KEY
    REFERENCES public.movie(movie_id) ON UPDATE CASCADE ON DELETE RESTRICT,  -- 1:1 with movie
  opening_weekend_revenue   NUMERIC(14,2),
  theatre_count             INTEGER
);

-- For the record we deleted some NULL rows:
DELETE FROM raw.sales_raw WHERE date_normalized IS NULL;  -- quick cleanse so casts/joins donâ€™t fail later

-- Load distribution
INSERT INTO public.distribution (movie_id, opening_weekend_revenue, theatre_count)
SELECT DISTINCT ON (m.movie_id)          -- one row per movie
  m.movie_id,
  CASE
    WHEN upper(btrim(s."opening_weekend")) IN ('', 'NULL') THEN NULL             -- map blanks/"NULL" to SQL NULL
    ELSE regexp_replace(s."opening_weekend", '[^0-9\.-]', '', 'g')::NUMERIC(14,2) -- remove symbols and cast
  END AS opening_weekend_revenue,
CASE
  WHEN upper(btrim(s."theatre_count")) IN ('', 'NULL') THEN NULL                  -- empty -> NULL for int column
  ELSE (NULLIF(regexp_replace(s."theatre_count", '[^0-9\.-]', '', 'g'), '')::NUMERIC)::INT  -- accept "2433.0" by NUMERIC->INT
END AS theatre_count
FROM raw.sales_raw s
JOIN public.movie m
  ON m.title = s."title"                                     -- same natural-key resolve
 AND m.reldate = s."date_normalized"::date                   -- source already castable; earlier NULLs removed
WHERE s."date_normalized" IS NOT NULL
ORDER BY m.movie_id;

-- Create entity USER_REVIEWS - Fatemeh
CREATE TABLE IF NOT EXISTS public.user_reviews (
  movie_id  BIGINT NOT NULL
    REFERENCES public.movie(movie_id) ON UPDATE CASCADE ON DELETE RESTRICT,  -- n:1 to movie
  reviewer  TEXT   NOT NULL,
  datep     DATE   NOT NULL,
  idvscore  INTEGER,
  CONSTRAINT user_reviews_pk PRIMARY KEY (movie_id, reviewer, datep)         -- composite PK prevents dup reviews
);

INSERT INTO public.user_reviews (movie_id, reviewer, datep, idvscore)
SELECT
  m.movie_id,
  r."reviewer",
  r."dateP"::date AS datep,                    -- rely on datestyle set at top; empty dates are filtered below
  NULLIF(btrim(r."idvscore"), '')::int         -- blank -> NULL before INT cast to avoid 22P02
FROM raw.userreviews_raw r
JOIN public.movie m ON m.url = r."url"         -- use url to link reviews to movie_id
WHERE r."url" IS NOT NULL
  AND r."reviewer" IS NOT NULL
  AND r."dateP" IS NOT NULL
ON CONFLICT (movie_id, reviewer, datep) DO NOTHING;  -- idempotent load (skip duplicates)

-- Create entity EXPERT_REVIEWS - Sreejoni
CREATE TABLE IF NOT EXISTS public.expert_reviews (
  movie_id             BIGINT NOT NULL
    REFERENCES public.movie(movie_id) ON UPDATE CASCADE ON DELETE RESTRICT,  -- n:1 to movie
  reviewer             TEXT,
  reviewer_normalized  TEXT NOT NULL,
  "date"               DATE NOT NULL,
  idvscore             INTEGER,
  CONSTRAINT expert_reviews_pk PRIMARY KEY (movie_id, reviewer_normalized, "date")  -- normalized reviewer for uniqueness
);

INSERT INTO public.expert_reviews (movie_id, reviewer, reviewer_normalized, "date", idvscore)
SELECT
  m.movie_id,
  e."reviewer",
  e."reviewer_normalized",
  NULLIF(btrim(e."date_normalized"), '')::date AS "date",  -- trim + NULLIF to avoid bad date casts
  NULLIF(btrim(e."idvscore"), '')::int                    -- same idea: blank scores -> NULL before INT cast
FROM raw.expertreviews_raw e
JOIN public.movie m ON m.url = e."url"                     -- link by url to get movie_id
WHERE e."url" IS NOT NULL
  AND e."reviewer_normalized" IS NOT NULL
  AND NULLIF(btrim(e."date_normalized"), '') IS NOT NULL   -- only load rows with a real date
ON CONFLICT (movie_id, reviewer_normalized, "date") DO NOTHING;  -- skip duplicates on reruns
