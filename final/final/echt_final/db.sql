-- Create raw sales table - Idris
CREATE TABLE IF NOT EXISTS raw.sales_raw (
  "year" TEXT,
  "release_date" TEXT,
  "title" TEXT,
  "genre" TEXT,
  "international_box_office" TEXT,
  "domestic_box_office" TEXT,
  "worldwide_box_office" TEXT,
  "production_budget" TEXT,
  "opening_weekend" TEXT,
  "theatre_count" TEXT,
  "avg_run_per_theatre" TEXT,
  "runtime" TEXT,
  "keywords" TEXT,
  "creative_type" TEXT,
  "url" TEXT,
  "date_normalized" TEXT
);

-- import:
--command " "\\copy \"raw\".sales_raw (year, release_date, title, genre, international_box_office, domestic_box_office, worldwide_box_office, production_budget, opening_weekend, theatre_count, avg_run_per_theatre, runtime, keywords, creative_type, url, date_normalized) FROM '/Users/tristanriethorst/Library/CloudStorage/OneDrive-Personal/HvA/Database design/clean/final_sales_clean_v1_fixed.csv' DELIMITER ',' CSV ENCODING 'UTF8' QUOTE '\"' ESCAPE '''';""

-- Create raw metaclean table - Tristan
CREATE TABLE IF NOT EXISTS raw.metaclean_raw (
  url TEXT,
  title TEXT,
  studio TEXT,
  rating TEXT,
  runtime TEXT,
  "cast" TEXT,
  director TEXT,
  genre TEXT,
  summary TEXT,
  awards TEXT,
  metascore TEXT,
  userscore TEXT,
  reldate TEXT
);

-- import:
--command " "\\copy \"raw\".metaclean_raw (url, title, studio, rating, runtime, \"cast\", director, genre, summary, awards, metascore, userscore, reldate) FROM '/Users/tristanriethorst/Library/CloudStorage/OneDrive-Personal/HvA/Database design/clean/metaClean43Brightspace_cleanv4.csv' DELIMITER ',' CSV HEADER ENCODING 'UTF8' QUOTE '\"';""

-- Create raw userreviews table - Fatemeh
CREATE SCHEMA IF NOT EXISTS raw;

CREATE TABLE IF NOT EXISTS raw.userreviews_raw (
  url      TEXT,
  idvscore TEXT,
  reviewer TEXT,
  "dateP"  TEXT
);

-- import:
--command " "\\copy \"raw\".userreviews_raw (url, idvscore, reviewer, \"dateP\") FROM '/Users/tristanriethorst/Library/CloudStorage/OneDrive-Personal/HvA/Database design/clean/final_UserReviews_cleanv3.csv' DELIMITER ',' CSV ENCODING 'UTF8' QUOTE '\"' ESCAPE '''';""


-- Create raw expertreviews table - Sreejoni
CREATE TABLE IF NOT EXISTS raw.expertreviews_raw (
  "url" TEXT,
  "reviewer" TEXT,
  "dateP" TEXT,
  "idvscore" TEXT,
  "reviewer_normalized" TEXT,
  "date_normalized" TEXT
);

-- import:
--command " "\\copy \"raw\".expertreviews_raw (url, reviewer, \"dateP\", idvscore, reviewer_normalized, date_normalized) FROM '/Users/tristanriethorst/Library/CloudStorage/OneDrive-Personal/HvA/Database design/clean/final_ExpertReviewsCleaned_DB_clean.csv' DELIMITER ',' CSV HEADER ENCODING 'UTF8' QUOTE '\"';""

SET datestyle = 'ISO, DMY';  -- ensure DD/MM/YYYY casts behave as expected

-- Create entity MOVIES - All
CREATE TABLE IF NOT EXISTS public.movie (
  movie_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,  -- surrogate key for stable references
  url      TEXT NOT NULL,
  title    TEXT NOT NULL,
  reldate  DATE NOT NULL,
  CONSTRAINT movie_url_uk                UNIQUE (url),            -- keep url unique for idempotent loads
  CONSTRAINT movie_title_reldate_uk      UNIQUE (title, reldate)  -- natural key kept for data quality
);

-- Load movies uit raw.metaclean_raw
INSERT INTO public.movie (url, title, reldate)
SELECT DISTINCT                          -- guard against duplicate source rows
  m."url",
  m."title",
  NULLIF(m."reldate", '')::DATE          -- empty string -> NULL before DATE cast to avoid 22P02
FROM raw.metaclean_raw m
WHERE NULLIF(m."url",'') IS NOT NULL     -- drop incomplete rows (avoid nulls into NOT NULL columns)
  AND NULLIF(m."title",'') IS NOT NULL
  AND NULLIF(m."reldate",'') IS NOT NULL
ON CONFLICT (url) DO UPDATE              -- upsert by url so re-runs are safe
SET title = EXCLUDED.title,
    reldate = EXCLUDED.reldate;

-- Create entity PERFORMANCE - Idris
CREATE TABLE IF NOT EXISTS public.performance (
  movie_id                  BIGINT PRIMARY KEY
    REFERENCES public.movie(movie_id) ON UPDATE CASCADE ON DELETE RESTRICT,  -- 1:1 with movie via surrogate key
  production_budget         NUMERIC(14,2),
  worldwide_box_office      NUMERIC(14,2),
  opening_weekend_revenue   NUMERIC(14,2)
);

-- Load performance via title+date -> movie_id
INSERT INTO public.performance (movie_id, production_budget, worldwide_box_office, opening_weekend_revenue)
SELECT DISTINCT ON (m.movie_id)          -- choose a single sales row per movie
  m.movie_id,
  NULLIF(regexp_replace(s."production_budget",    '[^0-9\.-]', '', 'g'), '')::NUMERIC(14,2),    -- strip currency/commas etc, empty->NULL, then cast
  NULLIF(regexp_replace(s."worldwide_box_office", '[^0-9\.-]', '', 'g'), '')::NUMERIC(14,2),    -- same normalization pattern
  NULLIF(regexp_replace(s."opening_weekend",      '[^0-9\.-]', '', 'g'), '')::NUMERIC(14,2)     -- keep two decimals consistently
FROM raw.sales_raw s
JOIN public.movie m
  ON m.title = s."title"                                                           -- resolve movie_id via natural key
 AND m.reldate = to_date(s."date_normalized",'DD/MM/YYYY')                         -- explicit format to avoid locale surprises
WHERE s."date_normalized" ~ '^\d{2}/\d{2}/\d{4}$'                                  -- guard: only rows with expected date format
ORDER BY m.movie_id;                                                                -- pairs with DISTINCT ON for deterministic pick


-- Create entity DISTRIBUTION - Tristan 
CREATE TABLE IF NOT EXISTS public.distribution (
  movie_id                  BIGINT PRIMARY KEY
    REFERENCES public.movie(movie_id) ON UPDATE CASCADE ON DELETE RESTRICT,  -- 1:1 with movie
  opening_weekend_revenue   NUMERIC(14,2),
  theatre_count             INTEGER,
  avg_run_per_theatre       NUMERIC(14,2)   -- NEW: comes from raw.sales_raw
);

-- For the record we deleted some NULL rows:
DELETE FROM raw.sales_raw WHERE date_normalized IS NULL;  -- quick cleanse so casts/joins donâ€™t fail later

-- Load distribution
INSERT INTO public.distribution (movie_id, opening_weekend_revenue, theatre_count, avg_run_per_theatre)
SELECT DISTINCT ON (m.movie_id)          -- one row per movie
  m.movie_id,
  CASE
    WHEN upper(btrim(s."opening_weekend")) IN ('', 'NULL') THEN NULL             -- map blanks/"NULL" to SQL NULL
    ELSE regexp_replace(s."opening_weekend", '[^0-9\.-]', '', 'g')::NUMERIC(14,2) -- remove symbols and cast
  END AS opening_weekend_revenue,
  CASE
    WHEN upper(btrim(s."theatre_count")) IN ('', 'NULL') THEN NULL                -- empty -> NULL for int column
    ELSE (NULLIF(regexp_replace(s."theatre_count", '[^0-9\.-]', '', 'g'), '')::NUMERIC)::INT  -- accept "2433.0" by NUMERIC->INT
  END AS theatre_count,
  CASE
    WHEN upper(btrim(s."avg_run_per_theatre")) IN ('', 'NULL') THEN NULL
    ELSE NULLIF(regexp_replace(s."avg_run_per_theatre", '[^0-9\.-]', '', 'g'), '')::NUMERIC(14,2)
  END AS avg_run_per_theatre
FROM raw.sales_raw s
JOIN public.movie m
  ON m.title = s."title"                                     -- same natural-key resolve
 AND m.reldate = s."date_normalized"::date                   -- source already castable; earlier NULLs removed
WHERE s."date_normalized" IS NOT NULL
ORDER BY m.movie_id;

-- =========================
-- Create entity USER_REVIEWS - Fatemeh (now ID-based PK)
-- =========================
CREATE TABLE IF NOT EXISTS public.user_reviews (
  review_id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,  -- NEW surrogate key
  movie_id  BIGINT NOT NULL
    REFERENCES public.movie(movie_id) ON UPDATE CASCADE ON DELETE RESTRICT,  -- n:1 to movie
  reviewer  TEXT   NOT NULL,
  datep     DATE   NOT NULL,
  idvscore  INTEGER,
  CONSTRAINT user_reviews_uk UNIQUE (movie_id, reviewer, datep)  -- keep natural uniqueness for idempotent loads
);

INSERT INTO public.user_reviews (movie_id, reviewer, datep, idvscore)
SELECT
  m.movie_id,
  r."reviewer",
  r."dateP"::date AS datep,                    -- rely on datestyle set at top; empty dates are filtered below
  NULLIF(btrim(r."idvscore"), '')::int         -- blank -> NULL before 22P02-prone cast
FROM raw.userreviews_raw r
JOIN public.movie m ON m.url = r."url"         -- use url to link reviews to movie_id
WHERE r."url" IS NOT NULL
  AND r."reviewer" IS NOT NULL
  AND r."dateP" IS NOT NULL
ON CONFLICT (movie_id, reviewer, datep) DO NOTHING;  -- idempotent load (duplicates skipped via UNIQUE)


-- =========================
-- Create entity EXPERT_REVIEWS - Sreejoni (now ID-based PK)
-- =========================
CREATE TABLE IF NOT EXISTS public.expert_reviews (
  expert_review_id    BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,  -- NEW surrogate key
  movie_id            BIGINT NOT NULL
    REFERENCES public.movie(movie_id) ON UPDATE CASCADE ON DELETE RESTRICT,  -- n:1 to movie
  reviewer            TEXT,
  reviewer_normalized TEXT NOT NULL,
  "date"              DATE NOT NULL,
  idvscore            INTEGER,
  CONSTRAINT expert_reviews_uk UNIQUE (movie_id, reviewer_normalized, "date")  -- natural uniqueness retained
);

INSERT INTO public.expert_reviews (movie_id, reviewer, reviewer_normalized, "date", idvscore)
SELECT
  m.movie_id,
  e."reviewer",
  e."reviewer_normalized",
  NULLIF(btrim(e."date_normalized"), '')::date AS "date",  -- trim + NULLIF to avoid bad date casts
  NULLIF(btrim(e."idvscore"), '')::int                    -- blank -> NULL before INT cast
FROM raw.expertreviews_raw e
JOIN public.movie m ON m.url = e."url"                     -- link by url to get movie_id
WHERE e."url" IS NOT NULL
  AND e."reviewer_normalized" IS NOT NULL
  AND NULLIF(btrim(e."date_normalized"), '') IS NOT NULL   -- only load rows with a real date
ON CONFLICT (movie_id, reviewer_normalized, "date") DO NOTHING;  -- idempotent re-runs
